# EngiGotchi
## Fall 2023
### Noah Monti, Kyle Sabado
### ECE241, University of Toronto

### Overview
EngiGotchi is a game created entirly in Verilog based off the handheld game Tamagotchi.

The game was written for the De1-Soc FPGA.

After starting the game, thought bubbles will appear on the screen that correspond to the demands of the pet. These demands can be met by flipping the corresponding switch on the board, where the object will fall down the screen and be recieved by the pet - failing to do so will cause the pet to become ill, and potentially pass away.

After enough time has elapsed in the game, the pet will become old and pass away regardless if its needs were met.

### Details

#### State Machine
- 25 state State Machine, with 15 active states

#### Board IO
- Includes output on six hex displays, with a corresponding custom decoder module.

#### Video
- Features 14 sprites, all created and instiantiated as .mif files, which were custom made from 24-bit .bmps

- Includes frame wait to ensure complete propegation of signals

- Each sprite is stored in video memory

- Manipulates the initial drawing locations of each sprite in an always block, which allows for the animation of sprites. Also has bounds checking to automatically end animation and the proper location.

- Features two splash screens and one background, all in 320x240.

- Uses a whopping eight colours for retro authenticity.

- Sprites have transparency, which allows us to select a colour to not appear on top of the background. This is accomplished through the AND'ing of the transparency condition with the plot enable so as to not plot undersired bits of a specific colour.

- The plot in datapath represents the plot enable in the VGA.

#### Audio 

There are two timers in sound module:

- The outer timer determines the length of the melody loop. The melody loop is cut into eight equal segments where sound can be on or off in each segment, the state of the enable signal determines if what is played. The breaks are for ensuring the each sound played is distinct, and not semi-combined.

- The inner loop is the waveform generator. The waverform generator runs a faster timer that flips a bit on and off depending on whether the signal to the DAC is all positive or all negative. Alternating the bit creates a waveform, which the DAC approximates a waveform from at the frequecy of the transitions between high and low. Shorter transitions creates higher pitched sounds, which is a triangle waveform.

- soundq is the quieter version of sound, and the waverform has smaller peaks.

- Features a two second main audio loop, with 16 possible notes.
Eight different audio loop segments are played based on the current state, and are repeated until the signal is low.
Has two counters, one that loops the audio, and one that generates the waveform for the DAC.
Also has selectable audio volume (two choices), as well as and on/off for audio.

- To emulate the simple sounds available with early electronics, music is generated by using an 
on/off timer tied to the system clock. When the timer limit is reached, the DAC is sent an
an alternating positive and negative integer of the same scale. This essentially creates a triangle
wave, whose frequency can be controlled by varying the length of the timer - a shorter timer
creates a higher-frequency sound, and a longer timer lowers the frequency.

- More complex sounds could be generated by either the use of a wavetable to lookup up timers and
volumes (integer scale) to send to the DAC, or by streaming a previously sampled sound in memory
to the DAC.

- To achieve different musical patterns, a separate timer defines the length of a music 'loop'.
Within the loop, counter values are compared to break up the loop into eight equal segements - each
of which can either play a sound or turn the sound off through an enable flag. 'IF' statements within
each segement of the loop determine the state of the pet and set the delay or sound disable flag
appropriately to generate sound tones. All of the loops are tied to the system clock, which 
enables sound to play synchronously with video generation and user input. Future enhancements
could also vary the volume per note, play a sample, or generate sounds from a wavetable.

#### Other Features
- Contains a real-time counter that is used to calculate the enables for many states and other logical operations

- Automatic ending of game based on counter value

- Automatic enabling of states based on counters and other parameters.

- Automatic state transitons from logical operations on stored values.

#### Future Features
- Make the pet a seperate entity from the background, to allow for it to be animated.

- Use .mif files for audio waveforms for more complex sounds.

- Add more variation in the movement of animated objects.

- Use a Linear-feedback Shift Register (LFSR) for randomization of state enables.

#### Other Notable Challenges
- Verilog has no modulus operatior, and slow divide operations. We used masking to compare bits as a fix.

- Had to reduce size of bits used to display images because of limited memory.

- It was difficult to get audio to switch automatically, had to feed states to get it to work.

### Sources
- VGA instantiation from UofT
  
- Audio instantiation from Intel, used some code from UofT audio demo, which instantiates the Intel audio controller

- Parameterize counter from Rurik Primiani & Wesley New

- Michael Wong and David Weitzenfield's implementation for an instantiation of altsyncram (video memory) & and the corresponding plotter to move through the memory, as well as their parameters for the frame wait counter

- Some project files such as the .sdc (system design) and the declaration of IO in toplevel are from the Terasic System Builder



